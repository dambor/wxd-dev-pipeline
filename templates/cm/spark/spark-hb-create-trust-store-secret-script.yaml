apiVersion: v1
data:
  create-trust-store-and-secret.sh: |-
    #!/bin/bash

    # A more robust version of create_secret_json that doesn't rely on `jq` or `sed`
    create_secret_json() {
        local secret_name=$1
        shift
        local paths=("$@")
        local tmp_file="/tmp/secret.json"

        # Start JSON
        printf '{"apiVersion":"v1", "kind":"Secret", "type":"Opaque", "metadata":{"name":"%s"}, "data":{' "$secret_name" > "$tmp_file"

        local first_entry=true
        for p in "${paths[@]}"; do
            if [ -f "$p" ]; then
                # Single file
                local key=$(basename "$p")
                local val=$(base64 -w0 "$p")
            elif [ -d "$p" ]; then
                # Folder → loop through files
                for f in "$p"/*; do
                    [ -f "$f" ] || continue
                    local key=$(basename "$f")
                    local val=$(base64 -w0 "$f")
                    
                    if [ "$first_entry" = true ]; then
                        printf '"%s":"%s"' "$key" "$val" >> "$tmp_file"
                        first_entry=false
                    else
                        printf ',"%s":"%s"' "$key" "$val" >> "$tmp_file"
                    fi
                done
                continue
            else
                echo "Warning: Skipping '$p' (not a file or directory)."
                continue
            fi

            if [ "$first_entry" = true ]; then
                printf '"%s":"%s"' "$key" "$val" >> "$tmp_file"
                first_entry=false
            else
                printf ',"%s":"%s"' "$key" "$val" >> "$tmp_file"
            fi
        done

        printf '}}' >> "$tmp_file"
        echo "$tmp_file"
    }


    exec_cmd()
    {
        CMD=$1
        eval $CMD
        if [ $? -ne 0 ]
        then
            echo "Error : failed to execute the command: $CMD"
            exit 1
        fi
    }

    check_exitcode()
    {
        if [ $1 -ne 0 ]
        then
            echo "Error : failed to create $2 secret"
            exit 1
        fi
    }

    k8s_api_call() {
        METHOD=$1
        URL=$2
        BODY_FILE=$3

        TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
        CACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
        API_SERVER="https://kubernetes.default.svc"

        if [ "$METHOD" == "DELETE" ]; then
            curl -s -k -o /dev/null -w "%{http_code}" \
              -X DELETE \
              "$API_SERVER/api/v1/namespaces/$NAMESPACE/secrets/$URL" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Accept: application/json"
        else
            curl -s -k -o /dev/null -w "%{http_code}" \
              -X $METHOD \
              "$API_SERVER/api/v1/namespaces/$NAMESPACE/secrets" \
              -H "Authorization: Bearer $TOKEN" \
              -H "Content-Type: application/json" \
              --data-binary @"$BODY_FILE"
        fi
    }

    # The `kubectl_retry` function is removed as it's no longer necessary

    truststore_password=$1
    truststore_secret_name=$2
    os_truststore_secret_name=$3
    icp4d_cert_path=$4
    custom_cert_path=$5

    #--------------------------
    # Main
    #--------------------------

    java_trust_store=/opt/java/openjdk/lib/security/cacerts
    nssdb_path=/etc/pki/nssdb
    echo "The custom_cert_path is $custom_cert_path"
    ls -al "$custom_cert_path"
    line_begin="-----BEGIN CERTIFICATE-----"
    count=0
    cert_file=$icp4d_cert_path/ca.crt
    tmp_cert_file=/tmp/certificate.pem
    tls_cert_file=$icp4d_cert_path/tls.crt
    tls_key_file=$icp4d_cert_path/tls.key
    cat "$cert_file" > "$tmp_cert_file"

    if [ -d "$custom_cert_path" ]; then
        content_count=$(ls -A "$custom_cert_path" | wc -l)
        expected_count=2
        if [ "$content_count" -gt "$expected_count" ]; then
            echo "$custom_cert_path directory exists"
            for custom_cert_file in "$custom_cert_path"/*; do
                echo "Adding file $custom_cert_file in $tmp_cert_file"
                echo -e "\\n" >> "$tmp_cert_file"
                cat "$custom_cert_file" >> "$tmp_cert_file"
            done
        fi
    fi
    echo -e "\\n" >> "$tmp_cert_file"
    cat "$tls_cert_file" >> "$tmp_cert_file"
    mkdir -p /tmp/certs/

    while read line ; do
        if [[ "$line" == "$line_begin" ]]
        then
        count=$(($count + 1))
        fi
        echo "$line" >> "/tmp/certs/cert_$count.pem"
    done < "$tmp_cert_file"

    for filename in /tmp/certs/*.pem
    do
        exec_cmd "keytool -importcert -alias $filename -file $filename -keystore $java_trust_store -storepass $truststore_password -noprompt"
    done

    echo -n "$truststore_password" > /tmp/password.txt

    if [ -n "$SSL_CERT_FILE" ]; then
        echo "Custom CA certificates enabled using admission controller"
    else
        echo "Custom CA certificates not enabled using admission controller"
        # Run the update-ca-trust command 
        exec_cmd "cp -r /tmp/certs/*.pem /etc/pki/ca-trust/source/anchors/"
        exec_cmd "update-ca-trust"
    fi

    exec_cmd "touch /tmp/tls-ca-bundle.pem"
    exec_cmd "cat /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem >> /tmp/tls-ca-bundle.pem"
    exec_cmd "cat $tmp_cert_file >> /tmp/tls-ca-bundle.pem"

    if [ -f "$tls_cert_file" ] && [ -f "$tls_key_file" ]
    then
        echo "Exporting internal-tls tls.crt and tls.key to create key.p12"
        exec_cmd "/usr/bin/openssl pkcs12 -export -keypbe AES-256-CBC -in $tls_cert_file -inkey $tls_key_file -out /tmp/key.p12 -name spark -passout pass:changeit"
        if [ -f "$cert_file" ]
        then
            echo "Importing internal-tls ca.crt in keystore"
            exec_cmd "keytool -importcert -noprompt -keystore /tmp/key.p12 -alias ca -storepass changeit -file $cert_file"
        fi
    fi

    echo "[INFO] Deleting old secrets if they exist"
    k8s_api_call DELETE "$truststore_secret_name" ""
    k8s_api_call DELETE "$os_truststore_secret_name" ""

    # ----------------------------
    # Create truststore secret
    # ----------------------------
    echo "[INFO] Creating $truststore_secret_name"
    # Pass only file paths, not directories
    TRUSTSTORE_SECRET_FILES=(
        "$java_trust_store"
        "/tmp/password.txt"
        "/tmp/key.p12"
        "$nssdb_path"
    )
    JSON_FILE=$(create_secret_json "$truststore_secret_name" "${TRUSTSTORE_SECRET_FILES[@]}")

    STATUS=$(k8s_api_call POST "" "$JSON_FILE")
    check_exitcode $([ "$STATUS" == "201" ] && echo 0 || echo 1) "$truststore_secret_name"

    # ----------------------------
    # Create os truststore secret
    # ----------------------------
    echo "[INFO] Creating $os_truststore_secret_name"
    OS_TRUSTSTORE_SECRET_FILES=(
        "/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt"
        "/tmp/tls-ca-bundle.pem"
    )
    JSON_FILE=$(create_secret_json "$os_truststore_secret_name" "${OS_TRUSTSTORE_SECRET_FILES[@]}")

    STATUS=$(k8s_api_call POST "" "$JSON_FILE")
    check_exitcode $([ "$STATUS" == "201" ] && echo 0 || echo 1) "$os_truststore_secret_name"

    echo "[INFO] SUCCESS — Secrets created"
    touch /tmp/SUCCESS
    while true
    do
        sleep 10000s
    done




kind: ConfigMap
metadata:
  annotations:
    helm.sh/hook: pre-install,pre-upgrade
    helm.sh/hook-delete-policy: before-hook-creation
    helm.sh/hook-weight: "5"
  name: spark-hb-create-trust-store-secret-script
  namespace: {{ .Release.Namespace }}